// ============================================
// KW APPS Subscription Service
// ============================================
// Handles subscription creation, renewal, cancellation, and rollover

import { createClient } from '@/lib/supabase/server';
import type {
  SubscriptionTierName,
  UserSubscription,
  CreateSubscriptionRequest,
  CreateSubscriptionResponse,
  SubscriptionTier,
  TransactionType,
} from '@/types/billing';
import { SUBSCRIPTION_TIERS, TRIAL_CONFIG } from '@/types/billing';

// ============================================
// Subscription Creation
// ============================================

/**
 * Create a new subscription for a user
 */
export async function createSubscription(
  userId: string,
  request: CreateSubscriptionRequest
): Promise<CreateSubscriptionResponse> {
  const supabase = await createClient();

  // Get the tier details
  const { data: tier, error: tierError } = await supabase
    .from('subscription_tiers')
    .select('*')
    .eq('name', request.tier_name)
    .eq('is_active', true)
    .single();

  if (tierError || !tier) {
    throw new Error(`Invalid tier: ${request.tier_name}`);
  }

  // Check if trial subscription (only for Basic tier)
  if (request.is_trial && request.tier_name !== 'basic') {
    throw new Error('Trial subscriptions are only available for Basic tier');
  }

  // Check if user already has an active subscription
  const { data: existing } = await supabase
    .from('user_subscriptions')
    .select('id, status')
    .eq('user_id', userId)
    .eq('status', 'active')
    .maybeSingle();

  if (existing) {
    throw new Error('User already has an active subscription');
  }

  // Calculate billing period
  const now = new Date();
  const periodEnd = new Date(now);

  if (request.is_trial) {
    // Trial is 7 days
    periodEnd.setDate(periodEnd.getDate() + TRIAL_CONFIG.duration_days);
  } else {
    // Regular subscription is 30 days (monthly)
    periodEnd.setDate(periodEnd.getDate() + 30);
  }

  // Create subscription
  const { data: subscription, error: subError } = await supabase
    .from('user_subscriptions')
    .insert({
      user_id: userId,
      tier_id: tier.id,
      status: request.is_trial ? ('trial' as const) : ('active' as const),
      is_trial: request.is_trial || false,
      trial_ends_at: request.is_trial ? periodEnd.toISOString() : null,
      current_period_start: now.toISOString(),
      current_period_end: periodEnd.toISOString(),
      credits_balance: tier.credits_per_month,
      credits_allocated_this_period: tier.credits_per_month,
      credits_bonus_earned: 0,
      credits_rollover: 0,
      payment_method: request.payment_method,
    })
    .select()
    .single();

  if (subError || !subscription) {
    throw new Error('Failed to create subscription');
  }

  // Create initial credit allocation transaction
  await supabase.from('credit_transactions').insert({
    user_id: userId,
    subscription_id: subscription.id,
    transaction_type: 'allocation' as TransactionType,
    amount: tier.credits_per_month,
    balance_after: tier.credits_per_month,
    description_ar: `تخصيص ${tier.credits_per_month} رصيد - ${tier.display_name_ar}`,
    description_en: `Allocated ${tier.credits_per_month} credits - ${tier.display_name_en}`,
  });

  // If trial, create trial record
  if (request.is_trial) {
    await supabase.from('trial_subscriptions').insert({
      user_id: userId,
      subscription_id: subscription.id,
      trial_price_kwd: TRIAL_CONFIG.price_kwd,
      trial_duration_days: TRIAL_CONFIG.duration_days,
      started_at: now.toISOString(),
      ends_at: periodEnd.toISOString(),
      payment_status: 'pending',
    });
  }

  return {
    subscription: subscription as UserSubscription,
    // payment_url would be generated by payment gateway integration
  };
}

// ============================================
// Subscription Renewal & Rollover
// ============================================

/**
 * Renew subscription for next billing period (with credit rollover)
 * This should be called by a cron job when period_end is reached
 */
export async function renewSubscription(
  subscriptionId: string
): Promise<void> {
  const supabase = await createClient();

  // Get subscription with tier info
  const { data: subscription, error: subError } = await supabase
    .from('user_subscriptions')
    .select(`
      *,
      subscription_tiers (
        credits_per_month,
        display_name_ar,
        display_name_en
      )
    `)
    .eq('id', subscriptionId)
    .single();

  if (subError || !subscription) {
    throw new Error('Subscription not found');
  }

  const tier = subscription.subscription_tiers as any;
  const unusedCredits = subscription.credits_balance;

  // Calculate new period dates (30 days from current end)
  const newPeriodStart = new Date(subscription.current_period_end);
  const newPeriodEnd = new Date(newPeriodStart);
  newPeriodEnd.setDate(newPeriodEnd.getDate() + 30);

  // Calculate new credit balance: base allocation + rollover
  const newCredits = tier.credits_per_month + unusedCredits;

  // Update subscription
  const { error: updateError } = await supabase
    .from('user_subscriptions')
    .update({
      current_period_start: newPeriodStart.toISOString(),
      current_period_end: newPeriodEnd.toISOString(),
      credits_balance: newCredits,
      credits_allocated_this_period: tier.credits_per_month,
      credits_bonus_earned: 0, // Reset bonus counter for new period
      credits_rollover: unusedCredits,
    })
    .eq('id', subscriptionId);

  if (updateError) {
    throw new Error('Failed to renew subscription');
  }

  // Create allocation transaction
  await supabase.from('credit_transactions').insert({
    user_id: subscription.user_id,
    subscription_id: subscriptionId,
    transaction_type: 'allocation' as TransactionType,
    amount: tier.credits_per_month,
    balance_after: newCredits,
    description_ar: `تجديد: ${tier.credits_per_month} رصيد جديد`,
    description_en: `Renewal: ${tier.credits_per_month} new credits`,
  });

  // If there was rollover, create rollover transaction
  if (unusedCredits > 0) {
    await supabase.from('credit_transactions').insert({
      user_id: subscription.user_id,
      subscription_id: subscriptionId,
      transaction_type: 'rollover' as TransactionType,
      amount: unusedCredits,
      balance_after: newCredits,
      description_ar: `ترحيل ${unusedCredits} رصيد من الفترة السابقة`,
      description_en: `Rollover: ${unusedCredits} credits from previous period`,
    });
  }
}

/**
 * Process all subscriptions due for renewal
 * Run this daily via cron job
 */
export async function processSubscriptionRenewals(): Promise<{
  processed: number;
  errors: number;
}> {
  const supabase = await createClient();

  // Get all active subscriptions where period has ended
  const now = new Date();
  const { data: subscriptions, error } = await supabase
    .from('user_subscriptions')
    .select('id')
    .eq('status', 'active')
    .lt('current_period_end', now.toISOString());

  if (error || !subscriptions) {
    console.error('Error fetching subscriptions for renewal:', error);
    return { processed: 0, errors: 0 };
  }

  let processed = 0;
  let errors = 0;

  for (const sub of subscriptions) {
    try {
      await renewSubscription(sub.id);
      processed++;
    } catch (err) {
      console.error(`Failed to renew subscription ${sub.id}:`, err);
      errors++;
    }
  }

  return { processed, errors };
}

// ============================================
// Subscription Cancellation
// ============================================

/**
 * Cancel a subscription
 */
export async function cancelSubscription(
  subscriptionId: string,
  reason?: string
): Promise<void> {
  const supabase = await createClient();

  const now = new Date();

  const { error } = await supabase
    .from('user_subscriptions')
    .update({
      status: 'cancelled',
      cancelled_at: now.toISOString(),
      cancellation_reason: reason || null,
    })
    .eq('id', subscriptionId);

  if (error) {
    throw new Error('Failed to cancel subscription');
  }

  // Note: User keeps their remaining credits until period end
  // They can still use the service until current_period_end
}

/**
 * Expire cancelled subscriptions that have reached their end date
 * Run this daily via cron job
 */
export async function expireCancelledSubscriptions(): Promise<number> {
  const supabase = await createClient();

  const now = new Date();
  const { data, error } = await supabase
    .from('user_subscriptions')
    .update({ status: 'expired' })
    .eq('status', 'cancelled')
    .lt('current_period_end', now.toISOString())
    .select('id');

  if (error) {
    console.error('Error expiring subscriptions:', error);
    return 0;
  }

  return data?.length || 0;
}

// ============================================
// Subscription Upgrade/Downgrade
// ============================================

/**
 * Upgrade or downgrade subscription to a different tier
 */
export async function changeSubscriptionTier(
  subscriptionId: string,
  newTierName: SubscriptionTierName
): Promise<void> {
  const supabase = await createClient();

  // Get current subscription
  const { data: subscription, error: subError } = await supabase
    .from('user_subscriptions')
    .select(`
      *,
      subscription_tiers!inner (
        name,
        credits_per_month
      )
    `)
    .eq('id', subscriptionId)
    .single();

  if (subError || !subscription) {
    throw new Error('Subscription not found');
  }

  // Get new tier
  const { data: newTier, error: tierError } = await supabase
    .from('subscription_tiers')
    .select('*')
    .eq('name', newTierName)
    .eq('is_active', true)
    .single();

  if (tierError || !newTier) {
    throw new Error('Invalid tier');
  }

  const currentTier = subscription.subscription_tiers as any;

  // Don't allow same tier
  if (currentTier.name === newTierName) {
    throw new Error('Already on this tier');
  }

  // Determine if upgrade or downgrade
  const isUpgrade = newTier.credits_per_month > currentTier.credits_per_month;

  // Calculate credit adjustment
  // For upgrades: Add difference immediately
  // For downgrades: No immediate change, takes effect next period
  let newBalance = subscription.credits_balance;
  let creditAdjustment = 0;

  if (isUpgrade) {
    const difference = newTier.credits_per_month - currentTier.credits_per_month;
    newBalance += difference;
    creditAdjustment = difference;
  }

  // Update subscription
  const { error: updateError } = await supabase
    .from('user_subscriptions')
    .update({
      tier_id: newTier.id,
      credits_balance: newBalance,
      credits_allocated_this_period: newTier.credits_per_month,
    })
    .eq('id', subscriptionId);

  if (updateError) {
    throw new Error('Failed to update subscription tier');
  }

  // Create transaction for upgrade credit adjustment
  if (isUpgrade && creditAdjustment > 0) {
    await supabase.from('credit_transactions').insert({
      user_id: subscription.user_id,
      subscription_id: subscriptionId,
      transaction_type: 'credit' as TransactionType,
      amount: creditAdjustment,
      balance_after: newBalance,
      description_ar: `ترقية الاشتراك: إضافة ${creditAdjustment} رصيد`,
      description_en: `Upgrade: Added ${creditAdjustment} credits`,
    });
  }
}

// ============================================
// Tier Information
// ============================================

/**
 * Get all available subscription tiers
 */
export async function getSubscriptionTiers(): Promise<SubscriptionTier[]> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('subscription_tiers')
    .select('*')
    .eq('is_active', true)
    .order('sort_order', { ascending: true });

  if (error) {
    throw new Error('Failed to fetch subscription tiers');
  }

  return data as SubscriptionTier[];
}

/**
 * Get user's current subscription
 */
export async function getUserSubscription(
  userId: string
): Promise<UserSubscription | null> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('user_subscriptions')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'active')
    .maybeSingle();

  if (error) {
    console.error('Error fetching user subscription:', error);
    return null;
  }

  return data as UserSubscription | null;
}
